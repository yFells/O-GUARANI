#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Chatbot "O Guarani" - Vers√£o Ultra Robusta com Import de Arquivo
Carrega o texto de O Guarani a partir do arquivo guarani.txt
"""

import numpy as np
import re
import os
from datetime import datetime
from typing import List, Dict
import time

class GuaraniChatbotUltraRobusta:
    """
    Chatbot O Guarani - Vers√£o que funciona 100% sem erros
    Carrega texto do arquivo guarani.txt
    """
    
    def __init__(self):
        print("üöÄ Inicializando Chatbot O Guarani (Vers√£o Ultra Robusta)")
        print("=" * 60)
        
        # Configura√ß√µes otimizadas
        self.chunk_size = 150
        self.overlap = 0.3
        self.similarity_threshold = 0.15
        self.top_chunks = 3
        
        # Estruturas de dados
        self.conversation_history = []
        self.processing_log = []
        self.performance_metrics = []
        self.text_chunks = []
        self.chunk_sentences = []
        
        # Stop words expandidas
        self.stop_words = {
            'a', 'o', 'e', 'de', 'da', 'do', 'em', 'um', 'uma', 'com', 'para',
            'por', 'que', 'se', 'na', 'no', 'ao', 'aos', 'as', 'os', 'mais',
            'mas', 'ou', 'ter', 'ser', 'estar', 'seu', 'sua', 'seus', 'suas',
            'foi', 's√£o', 'dos', 'das', 'pela', 'pelo', 'sobre', 'at√©', 'sem',
            'muito', 'bem', 'j√°', 'ainda', 's√≥', 'pode', 'tem', 'vai', 'vem',
            'ele', 'ela', 'eles', 'elas', 'isso', 'isto', 'aquilo', 'quando',
            'onde', 'como', 'porque', 'ent√£o', 'assim', 'aqui', 'ali', 'l√°',
            'me', 'te', 'nos', 'vos', 'lhe', 'lhes', 'meu', 'teu', 'nosso'
        }
        
        # Carregar texto do arquivo
        self.texto_guarani = self._carregar_texto_arquivo()
        
        if not self.texto_guarani:
            raise Exception("Falha ao carregar o arquivo guarani.txt")
        
        self._log("Sistema inicializado com sucesso")
    
    def _carregar_texto_arquivo(self) -> str:
        """Carrega o texto de O Guarani do arquivo guarani.txt"""
        arquivo_path = "guarani.txt"
        
        try:
            self._log("Tentando carregar guarani.txt...")
            
            # Verificar se o arquivo existe
            if not os.path.exists(arquivo_path):
                self._log(f"‚ùå Arquivo {arquivo_path} n√£o encontrado!")
                self._log("Criando arquivo de exemplo...")
                self._criar_arquivo_exemplo(arquivo_path)
                return self._carregar_arquivo_exemplo()
            
            # Tentar diferentes encodings
            encodings = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
            
            for encoding in encodings:
                try:
                    with open(arquivo_path, 'r', encoding=encoding) as file:
                        texto = file.read().strip()
                        
                    if texto and len(texto) > 100:  # Verificar se o texto n√£o est√° vazio
                        self._log(f"‚úÖ Arquivo carregado com encoding {encoding}")
                        self._log(f"üìÑ Tamanho do texto: {len(texto)} caracteres")
                        self._log(f"üìù Primeiras 100 chars: {texto[:100]}...")
                        return texto
                    else:
                        self._log(f"‚ö†Ô∏è Arquivo vazio ou muito pequeno com encoding {encoding}")
                        
                except UnicodeDecodeError:
                    self._log(f"‚ùå Falha com encoding {encoding}")
                    continue
                except Exception as e:
                    self._log(f"‚ùå Erro ao ler com {encoding}: {e}")
                    continue
            
            # Se chegou aqui, todas as tentativas falharam
            self._log("‚ùå Falha ao carregar com todos os encodings testados")
            self._log("üìù Usando texto de exemplo...")
            return self._carregar_arquivo_exemplo()
            
        except Exception as e:
            self._log(f"‚ùå Erro cr√≠tico ao carregar arquivo: {e}")
            self._log("üìù Usando texto de exemplo...")
            return self._carregar_arquivo_exemplo()
    
    def _criar_arquivo_exemplo(self, arquivo_path: str):
        """Cria um arquivo de exemplo com texto b√°sico de O Guarani"""
        texto_exemplo = """O Guarani √© um romance indianista de Jos√© de Alencar, publicado em 1857. A narrativa se desenvolve no s√©culo XVII, durante o per√≠odo colonial brasileiro, nas montanhas fluminenses pr√≥ximas ao rio Paquequer.

Peri √© o protagonista da obra, um √≠ndio goitac√° de for√ßa herc√∫lea e lealdade inabal√°vel. Ele √© descrito como um guerreiro corajoso, de estatura imponente e car√°ter nobre. Peri demonstra uma devo√ß√£o absoluta a Cec√≠lia (Ceci), filha do fidalgo portugu√™s Dom Ant√¥nio de Mariz.

Cec√≠lia, chamada carinhosamente de Ceci, √© uma jovem portuguesa de beleza singular e car√°ter doce. Ela √© filha de Dom Ant√¥nio de Mariz e representa a pureza e a inoc√™ncia feminina idealizadas pelo Romantismo.

Dom Ant√¥nio de Mariz √© um nobre portugu√™s, fidalgo da Casa Real, que se estabeleceu no Brasil ap√≥s cometer um crime de honra em Portugal. Ele construiu um castelo fortificado nas margens do rio Paquequer.

√Ålvaro √© um jovem portugu√™s, primo de Cec√≠lia, que tamb√©m habita o castelo. Ele encarna o ideal do cavaleiro medieval, sendo corajoso, nobre e apaixonado por Ceci.

Isabel √© irm√£ de Cec√≠lia, uma jovem impetuosa e apaixonada. Ela se enamora de √Ålvaro, criando um tri√¢ngulo amoroso que adiciona complexidade √†s rela√ß√µes familiares.

Os aimor√©s s√£o a tribo ind√≠gena antagonista, inimigos mortais de Peri e de sua tribo goitac√°. Eles representam o perigo constante que amea√ßa a seguran√ßa dos habitantes do castelo.

Loredano √© um dos antagonistas da hist√≥ria, um aventureiro italiano que se infiltra no castelo com inten√ß√µes mal√©volas. Ele planeja assassinar Dom Ant√¥nio e se apossar de suas riquezas.

A natureza brasileira desempenha papel fundamental na narrativa, sendo descrita com exuber√¢ncia e riqueza de detalhes. Alencar retrata as florestas, rios e montanhas como cen√°rio √©pico.

O romance explora temas centrais como o amor imposs√≠vel entre ra√ßas diferentes, representado pela rela√ß√£o entre Peri e Ceci. A lealdade e o sacrif√≠cio s√£o exemplificados pela devo√ß√£o absoluta do √≠ndio √† fam√≠lia Mariz."""
        
        try:
            with open(arquivo_path, 'w', encoding='utf-8') as file:
                file.write(texto_exemplo)
            self._log(f"‚úÖ Arquivo de exemplo criado: {arquivo_path}")
        except Exception as e:
            self._log(f"‚ùå Erro ao criar arquivo de exemplo: {e}")
    
    def _carregar_arquivo_exemplo(self) -> str:
        """Retorna texto de exemplo quando o arquivo n√£o pode ser carregado"""
        return """O Guarani √© um romance indianista de Jos√© de Alencar, publicado em 1857. A narrativa se desenvolve no s√©culo XVII, durante o per√≠odo colonial brasileiro, nas montanhas fluminenses pr√≥ximas ao rio Paquequer.

Peri √© o protagonista da obra, um √≠ndio goitac√° de for√ßa herc√∫lea e lealdade inabal√°vel. Ele √© descrito como um guerreiro corajoso, de estatura imponente e car√°ter nobre. Peri demonstra uma devo√ß√£o absoluta a Cec√≠lia (Ceci), filha do fidalgo portugu√™s Dom Ant√¥nio de Mariz. Esta devo√ß√£o representa o amor imposs√≠vel entre duas ra√ßas distintas.

Cec√≠lia, chamada carinhosamente de Ceci, √© uma jovem portuguesa de beleza singular e car√°ter doce. Ela √© filha de Dom Ant√¥nio de Mariz e representa a pureza e a inoc√™ncia feminina idealizadas pelo Romantismo. Ceci desenvolve sentimentos fraternais por Peri, vendo nele um protetor dedicado.

Dom Ant√¥nio de Mariz √© um nobre portugu√™s, fidalgo da Casa Real, que se estabeleceu no Brasil ap√≥s cometer um crime de honra em Portugal. Ele construiu um castelo fortificado nas margens do rio Paquequer, onde vive com sua fam√≠lia. Dom Ant√¥nio √© caracterizado como um homem honrado, mas marcado pelo passado.

√Ålvaro √© um jovem portugu√™s, primo de Cec√≠lia, que tamb√©m habita o castelo. Ele encarna o ideal do cavaleiro medieval, sendo corajoso, nobre e apaixonado por Ceci. √Ålvaro representa a civiliza√ß√£o europeia em contraste com a natureza selvagem de Peri.

Isabel √© irm√£ de Cec√≠lia, uma jovem impetuosa e apaixonada. Ela se enamora de √Ålvaro, criando um tri√¢ngulo amoroso que adiciona complexidade √†s rela√ß√µes familiares. Isabel possui um temperamento mais forte que sua irm√£.

Os aimor√©s s√£o a tribo ind√≠gena antagonista, inimigos mortais de Peri e de sua tribo goitac√°. Eles representam o perigo constante que amea√ßa a seguran√ßa dos habitantes do castelo. Os aimor√©s s√£o descritos como selvagens e canibais.

Loredano √© um dos antagonistas da hist√≥ria, um aventureiro italiano que se infiltra no castelo com inten√ß√µes mal√©volas. Ele planeja assassinar Dom Ant√¥nio e se apossar de suas riquezas, representando a trai√ß√£o e a vilania."""
    
    def _log(self, message: str):
        """Log seguro"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}"
        self.processing_log.append(log_entry)
        print(f"üìù {log_entry}")
    
    def verificar_arquivo_info(self):
        """Mostra informa√ß√µes sobre o arquivo carregado"""
        print(f"\nüìÅ INFORMA√á√ïES DO ARQUIVO")
        print("=" * 40)
        
        arquivo_path = "guarani.txt"
        
        try:
            if os.path.exists(arquivo_path):
                file_stats = os.stat(arquivo_path)
                file_size = file_stats.st_size
                mod_time = datetime.fromtimestamp(file_stats.st_mtime)
                
                print(f"üìÑ Arquivo: {arquivo_path}")
                print(f"üìè Tamanho: {file_size} bytes")
                print(f"üìÖ Modificado em: {mod_time.strftime('%d/%m/%Y %H:%M:%S')}")
                print(f"‚úÖ Status: Encontrado")
            else:
                print(f"üìÑ Arquivo: {arquivo_path}")
                print(f"‚ùå Status: N√£o encontrado")
                print(f"üí° O sistema criar√° um arquivo de exemplo se necess√°rio")
            
            if self.texto_guarani:
                words = len(self.texto_guarani.split())
                lines = len(self.texto_guarani.split('\n'))
                chars = len(self.texto_guarani)
                
                print(f"\nüìä CONTE√öDO CARREGADO:")
                print(f"   ‚Ä¢ Caracteres: {chars:,}")
                print(f"   ‚Ä¢ Palavras: {words:,}")
                print(f"   ‚Ä¢ Linhas: {lines:,}")
                print(f"   ‚Ä¢ Primeiros 150 chars: {self.texto_guarani[:150]}...")
            else:
                print(f"\n‚ùå Nenhum conte√∫do carregado")
                
        except Exception as e:
            print(f"‚ùå Erro ao verificar arquivo: {e}")
    
    def recarregar_arquivo(self):
        """Recarrega o arquivo guarani.txt"""
        print(f"\nüîÑ RECARREGANDO ARQUIVO...")
        
        try:
            novo_texto = self._carregar_texto_arquivo()
            
            if novo_texto and len(novo_texto) > 100:
                self.texto_guarani = novo_texto
                
                # Limpar dados processados para for√ßar reprocessamento
                self.text_chunks = []
                self.chunk_sentences = []
                
                print(f"‚úÖ Arquivo recarregado com sucesso!")
                print(f"üìè Novo tamanho: {len(self.texto_guarani)} caracteres")
                print(f"‚ö†Ô∏è Execute novamente as fases de processamento")
                return True
            else:
                print(f"‚ùå Falha ao recarregar arquivo")
                return False
                
        except Exception as e:
            print(f"‚ùå Erro ao recarregar: {e}")
            return False
    
    def fase1_analisar_texto(self):
        """Fase 1: An√°lise do texto"""
        self._log("=== FASE 1: AN√ÅLISE DO TEXTO ===")
        
        if not self.texto_guarani:
            self._log("‚ùå Texto n√£o carregado!")
            return False
        
        chars = len(self.texto_guarani)
        words = self.texto_guarani.split()
        sentences = self._segmentar_sentencas(self.texto_guarani)
        
        word_tokens = re.findall(r'\b\w+\b', self.texto_guarani.lower())
        unique_words = set(word_tokens)
        content_words = unique_words - self.stop_words
        
        self._log(f"Caracteres: {chars}")
        self._log(f"Palavras: {len(words)}")
        self._log(f"Senten√ßas: {len(sentences)}")
        self._log(f"Vocabul√°rio √∫nico: {len(unique_words)}")
        self._log(f"Palavras de conte√∫do: {len(content_words)}")
        
        return True
    
    def _segmentar_sentencas(self, texto: str) -> List[str]:
        """Segmenta√ß√£o robusta de senten√ßas"""
        # Limpeza inicial
        texto = re.sub(r'\n+', ' ', texto)
        texto = re.sub(r'\s+', ' ', texto).strip()
        
        # Segmenta√ß√£o por pontua√ß√£o
        sentences = re.split(r'[.!?]+', texto)
        sentences = [s.strip() for s in sentences if s.strip() and len(s.split()) > 2]
        
        return sentences
    
    def fase2_criar_chunks(self):
        """Fase 2: Cria√ß√£o de chunks"""
        self._log("=== FASE 2: CRIA√á√ÉO DE CHUNKS ===")
        
        if not self.texto_guarani:
            self._log("‚ùå Texto n√£o carregado!")
            return False
        
        sentences = self._segmentar_sentencas(self.texto_guarani)
        
        chunks = []
        chunk_sentences_map = []
        current_chunk_sentences = []
        current_word_count = 0
        
        for sentence in sentences:
            words = sentence.split()
            sentence_word_count = len(words)
            
            # Verificar se cabe no chunk atual
            if current_word_count + sentence_word_count <= self.chunk_size:
                current_chunk_sentences.append(sentence)
                current_word_count += sentence_word_count
            else:
                # Finalizar chunk atual
                if current_chunk_sentences:
                    chunk_text = '. '.join(current_chunk_sentences) + '.'
                    chunks.append(chunk_text)
                    chunk_sentences_map.append(current_chunk_sentences.copy())
                
                # Aplicar sobreposi√ß√£o
                overlap_size = int(len(current_chunk_sentences) * self.overlap)
                if overlap_size > 0 and len(current_chunk_sentences) > overlap_size:
                    current_chunk_sentences = current_chunk_sentences[-overlap_size:]
                    current_word_count = sum(len(s.split()) for s in current_chunk_sentences)
                else:
                    current_chunk_sentences = []
                    current_word_count = 0
                
                # Adicionar nova senten√ßa
                current_chunk_sentences.append(sentence)
                current_word_count += sentence_word_count
        
        # Finalizar √∫ltimo chunk
        if current_chunk_sentences:
            chunk_text = '. '.join(current_chunk_sentences) + '.'
            chunks.append(chunk_text)
            chunk_sentences_map.append(current_chunk_sentences.copy())
        
        self.text_chunks = chunks
        self.chunk_sentences = chunk_sentences_map
        
        # Estat√≠sticas
        if chunks:
            chunk_sizes = [len(chunk.split()) for chunk in chunks]
            avg_size = sum(chunk_sizes) / len(chunk_sizes)
            self._log(f"Chunks criados: {len(chunks)}")
            self._log(f"Tamanho m√©dio: {avg_size:.1f} palavras")
        
        return True
    
    def calcular_similaridade_jaccard_melhorada(self, pergunta: str, texto: str) -> float:
        """Similaridade Jaccard otimizada sem depend√™ncias"""
        try:
            # Preprocessamento seguro
            pergunta_words = set()
            texto_words = set()
            
            # Extrair palavras da pergunta
            for word in re.findall(r'\b\w+\b', pergunta.lower()):
                if len(word) > 2 and word not in self.stop_words:
                    pergunta_words.add(word)
            
            # Extrair palavras do texto
            for word in re.findall(r'\b\w+\b', texto.lower()):
                if len(word) > 2 and word not in self.stop_words:
                    texto_words.add(word)
            
            # Verificar se h√° palavras v√°lidas
            if not pergunta_words or not texto_words:
                return 0.0
            
            # C√°lculo Jaccard
            intersection = len(pergunta_words & texto_words)
            union = len(pergunta_words | texto_words)
            jaccard = intersection / union if union > 0 else 0.0
            
            # Bonus para matches importantes
            important_words = pergunta_words - {'quem', 'qual', 'onde', 'como', 'quando', 'sobre', 'fale', 'conte', 'descreva'}
            exact_matches = len(important_words & texto_words)
            bonus = min(exact_matches * 0.1, 0.3)
            
            # Bonus para palavras-chave espec√≠ficas
            key_words = {'peri', 'cec√≠lia', 'ceci', 'antonio', 'mariz', 'alvaro', 'isabel', 'aimores', 'guarani', 'alencar'}
            key_matches = len((pergunta_words & key_words) & (texto_words & key_words))
            key_bonus = min(key_matches * 0.15, 0.2)
            
            final_similarity = min(jaccard + bonus + key_bonus, 1.0)
            
            return float(final_similarity)  # Garantir que retorna float
            
        except Exception as e:
            self._log(f"Erro no c√°lculo de similaridade: {e}")
            return 0.0
    
    def fase3_responder_pergunta(self, pergunta: str) -> str:
        """Fase 3: Resposta √† pergunta (vers√£o ultra robusta)"""
        start_time = time.time()
        self._log(f"=== CONSULTA: {pergunta} ===")
        
        if not self.text_chunks:
            return "‚ùå Sistema n√£o processado. Execute as fases anteriores."
        
        try:
            # Calcular similaridades de forma segura
            similarities = []
            for chunk in self.text_chunks:
                sim = self.calcular_similaridade_jaccard_melhorada(pergunta, chunk)
                similarities.append(float(sim))  # Garantir que √© float
            
            # Verificar se temos similaridades v√°lidas
            if not similarities:
                return "‚ùå Erro no c√°lculo de similaridades."
            
            # Criar resultados de forma segura
            chunk_results = []
            for i, sim in enumerate(similarities):
                chunk_results.append({
                    'chunk_id': i,
                    'chunk': self.text_chunks[i],
                    'similarity': float(sim),  # Garantir float
                    'sentences': self.chunk_sentences[i] if i < len(self.chunk_sentences) else []
                })
            
            # Ordenar por similaridade
            chunk_results.sort(key=lambda x: x['similarity'], reverse=True)
            
            # Estat√≠sticas seguras
            max_sim = chunk_results[0]['similarity'] if chunk_results else 0.0
            mean_sim = sum(similarities) / len(similarities) if similarities else 0.0
            
            self._log(f"Similaridade m√°xima: {max_sim:.3f}")
            self._log(f"Similaridade m√©dia: {mean_sim:.3f}")
            
            # Filtrar chunks relevantes de forma segura
            relevant_chunks = []
            for chunk in chunk_results:
                if chunk['similarity'] >= self.similarity_threshold:
                    relevant_chunks.append(chunk)
            
            self._log(f"Chunks relevantes: {len(relevant_chunks)}")
            
            # Gerar resposta
            if not relevant_chunks:
                response = self._resposta_nao_encontrada(pergunta, max_sim)
            else:
                response = self._gerar_resposta_segura(pergunta, relevant_chunks[:self.top_chunks])
            
            # M√©tricas
            processing_time = time.time() - start_time
            self.performance_metrics.append({
                'pergunta': pergunta,
                'tempo': processing_time,
                'max_similarity': max_sim,
                'chunks_relevantes': len(relevant_chunks)
            })
            
            # Hist√≥rico
            self.conversation_history.append({
                'pergunta': pergunta,
                'resposta': response,
                'similaridade_max': max_sim,
                'chunks_usados': len(relevant_chunks),
                'tempo_resposta': processing_time,
                'timestamp': datetime.now()
            })
            
            self._log(f"Resposta gerada em {processing_time:.3f}s")
            return response
            
        except Exception as e:
            error_msg = f"‚ùå Erro inesperado: {e}"
            self._log(error_msg)
            return error_msg
    
    def _resposta_nao_encontrada(self, pergunta: str, max_sim: float) -> str:
        """Resposta quando n√£o encontra informa√ß√µes"""
        base_msg = "N√£o encontrei informa√ß√µes espec√≠ficas sobre sua pergunta no texto de 'O Guarani'."
        
        if max_sim > 0.1:
            suggestion = "\n\nüí° Tente reformular usando termos mais espec√≠ficos da obra."
        elif max_sim > 0.05:
            suggestion = "\n\nüí° Use nomes de personagens ou eventos espec√≠ficos."
        else:
            suggestion = "\n\nüí° Sua pergunta pode estar fora do escopo da obra."
        
        examples = """
\nüìù Exemplos de perguntas eficazes:
‚Ä¢ "Quem √© Peri?" ou "Fale sobre Peri"
‚Ä¢ "Quem √© Cec√≠lia?" ou "Descreva Ceci"
‚Ä¢ "Qual a rela√ß√£o entre Peri e Cec√≠lia?"
‚Ä¢ "Quem s√£o os aimor√©s?"
‚Ä¢ "Onde se passa a hist√≥ria?"
‚Ä¢ "Quem √© Dom Ant√¥nio de Mariz?"
‚Ä¢ "Fale sobre √Ålvaro"
‚Ä¢ "Quem √© Isabel?"
"""
        
        confidence = f"\n\nüî¥ Confian√ßa muito baixa (similaridade m√°xima: {max_sim:.3f})"
        
        return base_msg + suggestion + examples + confidence
    
    def _gerar_resposta_segura(self, pergunta: str, chunks: List[Dict]) -> str:
        """Gera resposta de forma segura"""
        if not chunks:
            return self._resposta_nao_encontrada(pergunta, 0.0)
        
        try:
            best_chunk = chunks[0]
            
            # Tentar busca por senten√ßa se dispon√≠vel
            if best_chunk.get('sentences'):
                sentences = best_chunk['sentences']
                best_sentence = ""
                best_sentence_sim = 0.0
                
                for sentence in sentences:
                    sim = self.calcular_similaridade_jaccard_melhorada(pergunta, sentence)
                    if sim > best_sentence_sim:
                        best_sentence_sim = sim
                        best_sentence = sentence
                
                # Se encontrou uma boa senten√ßa, usar ela
                if best_sentence_sim > 0.2 and best_sentence:
                    confidence = self._calcular_confianca(best_sentence_sim)
                    return f"Com base em 'O Guarani':\n\n{best_sentence}\n\n{confidence}"
            
            # Usar chunk completo
            if len(chunks) == 1:
                main_content = chunks[0]['chunk']
                intro = "Com base no texto de 'O Guarani':\n\n"
            else:
                # Combinar chunks (limitado para evitar texto muito longo)
                combined_chunks = []
                total_length = 0
                for chunk in chunks[:2]:  # M√°ximo 2 chunks
                    chunk_text = chunk['chunk']
                    if total_length + len(chunk_text) < 600:
                        combined_chunks.append(chunk_text)
                        total_length += len(chunk_text)
                    else:
                        break
                
                main_content = ". ".join(combined_chunks)
                intro = "Combinando informa√ß√µes de 'O Guarani':\n\n"
            
            # Truncar se muito longo
            if len(main_content) > 500:
                main_content = main_content[:500] + "..."
            
            confidence = self._calcular_confianca(best_chunk['similarity'])
            return intro + main_content + "\n\n" + confidence
            
        except Exception as e:
            self._log(f"Erro na gera√ß√£o de resposta: {e}")
            return f"‚ùå Erro ao gerar resposta: {e}"
    
    def _calcular_confianca(self, similarity: float) -> str:
        """Calcula indicador de confian√ßa"""
        try:
            sim = float(similarity)
            if sim > 0.5:
                return "üü¢ Confian√ßa muito alta"
            elif sim > 0.35:
                return "üü¢ Confian√ßa alta"
            elif sim > 0.25:
                return "üü° Confian√ßa moderada"
            elif sim > 0.15:
                return "üü† Confian√ßa baixa - considere reformular"
            else:
                return "üî¥ Confian√ßa muito baixa"
        except:
            return "‚ö†Ô∏è Confian√ßa indeterminada"
    
    def executar_sistema_completo(self):
        """Executa todas as fases"""
        try:
            self._log("üöÄ EXECUTANDO SISTEMA COMPLETO")
            
            if not self.fase1_analisar_texto():
                raise Exception("Erro na Fase 1")
            
            if not self.fase2_criar_chunks():
                raise Exception("Erro na Fase 2")
            
            self._log("‚úÖ Sistema pronto para consultas!")
            return True
            
        except Exception as e:
            self._log(f"‚ùå Erro na execu√ß√£o: {e}")
            return False
    
    def executar_testes_automaticos(self):
        """Testes autom√°ticos ultra robustos"""
        perguntas_teste = [
            "Quem √© Peri?",
            "Fale sobre Cec√≠lia",
            "Quem √© Dom Ant√¥nio de Mariz?",
            "Descreva √Ålvaro",
            "Qual a rela√ß√£o entre Peri e Cec√≠lia?",
            "Quem Isabel ama?",
            "Quem s√£o os aimor√©s?",
            "Fale sobre Loredano",
            "Onde se passa a hist√≥ria?",
            "Quando foi publicado O Guarani?",
            "Quais s√£o os temas da obra?",
            "Como √© descrita a natureza?",
            "Como fazer um bolo?",  # Deve ser rejeitada
            "Qual a capital da Fran√ßa?"  # Deve ser rejeitada
        ]
        
        print(f"\nüß™ EXECUTANDO TESTES AUTOM√ÅTICOS ({len(perguntas_teste)} perguntas)")
        print("=" * 70)
        
        resultados = []
        
        for i, pergunta in enumerate(perguntas_teste, 1):
            print(f"\nüìã Teste {i:2d}/{len(perguntas_teste)}: {pergunta}")
            
            try:
                resposta = self.fase3_responder_pergunta(pergunta)
                ultimo_historico = self.conversation_history[-1]
                qualidade = self._avaliar_qualidade(ultimo_historico['similaridade_max'])
                
                resultado = {
                    'pergunta': pergunta,
                    'tempo': ultimo_historico['tempo_resposta'],
                    'similaridade': ultimo_historico['similaridade_max'],
                    'qualidade': qualidade
                }
                resultados.append(resultado)
                
                print(f"   ‚è±Ô∏è  {ultimo_historico['tempo_resposta']:.3f}s | üìä {ultimo_historico['similaridade_max']:.3f} | {qualidade}")
                
                # Mostrar in√≠cio da resposta se relevante
                if ultimo_historico['similaridade_max'] > 0.1:
                    print(f"   üí¨ {resposta[:80]}...")
                
            except Exception as e:
                print(f"   ‚ùå ERRO: {e}")
                resultado = {
                    'pergunta': pergunta,
                    'tempo': 0.0,
                    'similaridade': 0.0,
                    'qualidade': "‚ùå Erro"
                }
                resultados.append(resultado)
        
        # Relat√≥rio final
        self._relatorio_testes_seguro(resultados)
        return resultados
    
    def _avaliar_qualidade(self, similaridade: float) -> str:
        """Avalia qualidade da resposta"""
        try:
            sim = float(similaridade)
            if sim > 0.4:
                return "üü¢ Excelente"
            elif sim > 0.25:
                return "üü° Boa"
            elif sim > 0.15:
                return "üü† Regular"
            elif sim > 0.05:
                return "üî¥ Ruim"
            else:
                return "‚ùå Irrelevante"
        except:
            return "‚ö†Ô∏è Indeterminada"
    
    def _relatorio_testes_seguro(self, resultados: List[Dict]):
        """Relat√≥rio seguro dos testes"""
        print(f"\nüìã RELAT√ìRIO DOS TESTES")
        print("=" * 50)
        
        try:
            # Calcular m√©tricas de forma segura
            tempos = [float(r.get('tempo', 0)) for r in resultados if r.get('tempo') is not None]
            similaridades = [float(r.get('similaridade', 0)) for r in resultados if r.get('similaridade') is not None]
            qualidades = [r.get('qualidade', 'Indeterminada') for r in resultados]
            
            if tempos:
                tempo_medio = sum(tempos) / len(tempos)
                print(f"üìä M√âTRICAS:")
                print(f"   ‚Ä¢ Tempo m√©dio: {tempo_medio:.3f}s")
            
            if similaridades:
                sim_media = sum(similaridades) / len(similaridades)
                print(f"   ‚Ä¢ Similaridade m√©dia: {sim_media:.3f}")
                print(f"   ‚Ä¢ Similaridade m√°xima: {max(similaridades):.3f}")
            
            # Contagem de qualidades
            contadores = {}
            for qual in qualidades:
                contadores[qual] = contadores.get(qual, 0) + 1
            
            total = len(resultados)
            print(f"\nüéØ QUALIDADE:")
            
            qualidade_ordem = ["üü¢ Excelente", "üü° Boa", "üü† Regular", "üî¥ Ruim", "‚ùå Irrelevante", "‚ùå Erro"]
            for qual in qualidade_ordem:
                count = contadores.get(qual, 0)
                if count > 0:
                    percent = (count / total * 100) if total > 0 else 0
                    print(f"   ‚Ä¢ {qual}: {count}/{total} ({percent:.1f}%)")
            
            # An√°lise geral
            sucessos = contadores.get("üü¢ Excelente", 0) + contadores.get("üü° Boa", 0)
            taxa_sucesso = (sucessos / total * 100) if total > 0 else 0
            
            print(f"\nüìà AN√ÅLISE GERAL:")
            print(f"   ‚Ä¢ Taxa de sucesso: {taxa_sucesso:.1f}%")
            
            if taxa_sucesso > 70:
                print("   ‚úÖ Sistema funcionando muito bem!")
            elif taxa_sucesso > 50:
                print("   üü° Sistema funcionando adequadamente")
            else:
                print("   ‚ö†Ô∏è Sistema pode ser melhorado")
                
        except Exception as e:
            print(f"‚ùå Erro no relat√≥rio: {e}")
    
    def mostrar_estatisticas(self):
        """Estat√≠sticas do sistema"""
        print(f"\nüìä ESTAT√çSTICAS DO SISTEMA")
        print("=" * 40)
        
        try:
            print(f"üìù Chunks: {len(self.text_chunks)}")
            print(f"üîß Threshold: {self.similarity_threshold}")
            print(f"üìè Tamanho chunks: {self.chunk_size} palavras")
            print(f"üîÑ Sobreposi√ß√£o: {self.overlap * 100}%")
            print(f"üí¨ Consultas: {len(self.conversation_history)}")
            print(f"üõ†Ô∏è M√©todo: Jaccard otimizado")
            print(f"üõ°Ô∏è Stop words: {len(self.stop_words)}")
            
            if self.texto_guarani:
                words = len(self.texto_guarani.split())
                chars = len(self.texto_guarani)
                print(f"üìÑ Texto carregado: {chars:,} chars, {words:,} palavras")
            
            if self.performance_metrics:
                tempos = [float(m.get('tempo', 0)) for m in self.performance_metrics if m.get('tempo')]
                if tempos:
                    print(f"‚è±Ô∏è Tempo m√©dio: {sum(tempos)/len(tempos):.3f}s")
            
            if self.conversation_history:
                similarities = [float(c.get('similaridade_max', 0)) for c in self.conversation_history if c.get('similaridade_max')]
                if similarities:
                    print(f"üìà Similaridade m√©dia: {sum(similarities)/len(similarities):.3f}")
                    
        except Exception as e:
            print(f"‚ùå Erro nas estat√≠sticas: {e}")
    
    def interface_chat(self):
        """Interface de chat ultra robusta"""
        print(f"\nü§ñ CHATBOT O GUARANI - CHAT INTERATIVO")
        print("=" * 50)
        print("Comandos especiais:")
        print("  ‚Ä¢ 'sair' - Encerrar chat")
        print("  ‚Ä¢ 'stats' - Ver estat√≠sticas")
        print("  ‚Ä¢ 'teste' - Executar testes")
        print("  ‚Ä¢ 'help' - Mostrar ajuda")
        print("  ‚Ä¢ 'arquivo' - Info sobre arquivo")
        print("  ‚Ä¢ 'reload' - Recarregar arquivo")
        print("=" * 50)
        
        while True:
            try:
                pergunta = input("\nüí¨ Sua pergunta: ").strip()
                
                if not pergunta:
                    print("‚ö†Ô∏è Digite uma pergunta ou comando.")
                    continue
                
                if pergunta.lower() in ['sair', 'exit', 'quit', 'tchau']:
                    print("üëã At√© logo!")
                    break
                elif pergunta.lower() in ['stats', 'estatisticas', 'estat√≠sticas']:
                    self.mostrar_estatisticas()
                    continue
                elif pergunta.lower() in ['teste', 'testes', 'test']:
                    self.executar_testes_automaticos()
                    continue
                elif pergunta.lower() in ['help', 'ajuda', '?']:
                    self._mostrar_ajuda()
                    continue
                elif pergunta.lower() in ['arquivo', 'file', 'info']:
                    self.verificar_arquivo_info()
                    continue
                elif pergunta.lower() in ['reload', 'recarregar', 'refresh']:
                    if self.recarregar_arquivo():
                        print("‚ö†Ô∏è Execute 'stats' para ver nova informa√ß√£o ou reinicie o processamento")
                    continue
                
                # Processar pergunta normal
                try:
                    resposta = self.fase3_responder_pergunta(pergunta)
                    print(f"\nü§ñ {resposta}")
                except Exception as e:
                    print(f"\n‚ùå Erro ao processar pergunta: {e}")
                    print("Tente reformular sua pergunta.")
                
            except KeyboardInterrupt:
                print("\nüëã Encerrando...")
                break
            except Exception as e:
                print(f"\n‚ùå Erro inesperado: {e}")
                print("Digite 'sair' para encerrar ou continue tentando.")
    
    def _mostrar_ajuda(self):
        """Mostra ajuda detalhada"""
        help_text = """
üÜò AJUDA - CHATBOT O GUARANI

üìÅ ARQUIVO:
   ‚Ä¢ O sistema carrega o texto do arquivo 'guarani.txt'
   ‚Ä¢ Se n√£o encontrar, cria um arquivo de exemplo
   ‚Ä¢ Use 'arquivo' para ver informa√ß√µes do arquivo
   ‚Ä¢ Use 'reload' para recarregar o arquivo

üìù PERGUNTAS QUE FUNCIONAM BEM:

üßë Personagens:
   ‚Ä¢ "Quem √© Peri?" / "Fale sobre Peri"
   ‚Ä¢ "Quem √© Cec√≠lia?" / "Descreva Ceci"
   ‚Ä¢ "Quem √© Dom Ant√¥nio de Mariz?"
   ‚Ä¢ "Fale sobre √Ålvaro"
   ‚Ä¢ "Quem √© Isabel?"

üíï Relacionamentos:
   ‚Ä¢ "Qual a rela√ß√£o entre Peri e Cec√≠lia?"
   ‚Ä¢ "Quem Isabel ama?"
   ‚Ä¢ "Por que Peri √© devotado √† Ceci?"

üè∞ Contexto:
   ‚Ä¢ "Onde se passa a hist√≥ria?"
   ‚Ä¢ "Quando foi publicado O Guarani?"
   ‚Ä¢ "Como √© o castelo?"

‚öîÔ∏è Conflitos:
   ‚Ä¢ "Quem s√£o os aimor√©s?"
   ‚Ä¢ "Fale sobre Loredano"
   ‚Ä¢ "Quais s√£o os perigos?"

üé≠ Temas:
   ‚Ä¢ "Quais s√£o os temas principais?"
   ‚Ä¢ "Como √© descrita a natureza?"
   ‚Ä¢ "O que a obra representa?"

üí° DICAS:
   ‚Ä¢ Seja espec√≠fico nos nomes
   ‚Ä¢ Use termos da obra
   ‚Ä¢ Reformule se n√£o obtiver boa resposta
   ‚Ä¢ Perguntas diretas funcionam melhor

‚ùå EVITE:
   ‚Ä¢ Perguntas muito vagas
   ‚Ä¢ Temas fora da obra
   ‚Ä¢ Perguntas sobre outros livros

üîß COMANDOS:
   ‚Ä¢ 'arquivo' - Ver info do arquivo guarani.txt
   ‚Ä¢ 'reload' - Recarregar arquivo se modificado
   ‚Ä¢ 'stats' - Ver estat√≠sticas do sistema
   ‚Ä¢ 'teste' - Executar bateria de testes
        """
        print(help_text)

def main():
    """Fun√ß√£o principal ultra robusta"""
    print("üéØ CHATBOT O GUARANI - VERS√ÉO COM IMPORT DE ARQUIVO")
    print("=" * 60)
    print("Esta vers√£o carrega o texto do arquivo 'guarani.txt'")
    print("Se o arquivo n√£o existir, um exemplo ser√° criado automaticamente.")
    print()
    
    try:
        chatbot = GuaraniChatbotUltraRobusta()
        
        # Mostrar informa√ß√µes do arquivo carregado
        chatbot.verificar_arquivo_info()
        
        if chatbot.executar_sistema_completo():
            print("\n‚úÖ Sistema inicializado com sucesso!")
            print("üõ°Ô∏è Vers√£o ultra robusta - √† prova de erros!")
            print("üìÅ Texto carregado do arquivo guarani.txt")
            
            # Menu principal
            while True:
                print("\nüéØ MENU PRINCIPAL:")
                print("1. üí¨ Chat interativo")
                print("2. üß™ Testes autom√°ticos")
                print("3. üìä Estat√≠sticas do sistema")
                print("4. üìÅ Informa√ß√µes do arquivo")
                print("5. üîÑ Recarregar arquivo")
                print("6. üÜò Ajuda e exemplos")
                print("7. üö™ Sair")
                
                try:
                    opcao = input("\nEscolha uma op√ß√£o (1-7): ").strip()
                    
                    if opcao == '1':
                        chatbot.interface_chat()
                    elif opcao == '2':
                        chatbot.executar_testes_automaticos()
                    elif opcao == '3':
                        chatbot.mostrar_estatisticas()
                    elif opcao == '4':
                        chatbot.verificar_arquivo_info()
                    elif opcao == '5':
                        if chatbot.recarregar_arquivo():
                            print("‚úÖ Arquivo recarregado! Reprocessando...")
                            if chatbot.executar_sistema_completo():
                                print("‚úÖ Sistema reprocessado com sucesso!")
                            else:
                                print("‚ùå Erro no reprocessamento")
                    elif opcao == '6':
                        chatbot._mostrar_ajuda()
                    elif opcao == '7':
                        print("üëã Encerrando sistema...")
                        break
                    else:
                        print("‚ùå Op√ß√£o inv√°lida. Digite um n√∫mero de 1 a 7.")
                        
                except KeyboardInterrupt:
                    print("\nüëã Encerrando...")
                    break
                except Exception as e:
                    print(f"‚ùå Erro no menu: {e}")
                    print("Tente novamente ou digite 7 para sair.")
        else:
            print("‚ùå Falha na inicializa√ß√£o do sistema")
            
    except Exception as e:
        print(f"‚ùå Erro cr√≠tico: {e}")
        print("Verifique se Python e NumPy est√£o instalados corretamente.")
        print("Certifique-se de que o arquivo 'guarani.txt' existe ou pode ser criado.")

if __name__ == "__main__":
    main()